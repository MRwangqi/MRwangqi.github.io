<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>JNI 之 Libjpeg 分析</title>
      <link href="/2020/02/22/JNI%20%E4%B9%8B%20Libjpeg%20%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/22/JNI%20%E4%B9%8B%20Libjpeg%20%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>关于为什么使用 Libjpeg 来压缩图片的原因可以看 <a href="https://github.com/bither/bither-android-lib/blob/master/REASON.md" target="_blank" rel="noopener">REASON.md</a>，skia 引擎也是基于 libjpeg 的封装</p><p>libjpeg 的 Android jni 库地址:<a href="https://github.com/bither/bither-android-lib" target="_blank" rel="noopener">https://github.com/bither/bither-android-lib</a>，可以直接将该库的 jni 文件夹直接拷贝至项目下，通过 cmake 引入构建。</p><p><a name="QLzOM"></a></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>下面介绍的两个库都是基于 <a href="https://github.com/bither/bither-android-lib" target="_blank" rel="noopener">bither-android-lib</a> 来实现的。</p><p><a name="bq9U9"></a></p><h3 id="1、Luban"><a href="#1、Luban" class="headerlink" title="1、Luban"></a>1、Luban</h3><p>luban 这个库大家用的还是比较多的，但 luban 是基于 java 层面去压缩的，主要就是对 bitmap 的 options.inSampleSize 进行一个算法计算，具体可以查看源码 <a href="https://github.com/Curzibn/Luban/blob/d1fca89f2564e995cbdd9defb8000e5212ab5000/library/src/main/java/top/zibin/luban/Engine.java#L36" target="_blank" rel="noopener">computeSize</a> 方法。</p><p>而在 luban 的项目中，其实还有另一个通过 libjpeg 来实现的的压缩库，在 luban 的 <a href="https://github.com/Curzibn/Luban/tree/turbo" target="_blank" rel="noopener">turbor</a> 分支中，但该分支中只有编译好后的 so 文件和项目使用，具体的源码是在 <a href="https://github.com/Curzibn/Luban-Turbo" target="_blank" rel="noopener">Luban-Turbo</a> 项目中，我们可以来看下他的项目目录：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162327/1576398781538-2bf21e97-7b43-4666-98f9-213742dc6e4e.png#align=left&amp;display=inline&amp;height=322&amp;name=image.png&amp;originHeight=644&amp;originWidth=718&amp;size=63799&amp;status=done&amp;style=none&amp;width=359" alt="image.png"><br><br><br>介绍：<br>1、include 文件夹就是开头指的 <a href="https://github.com/bither/bither-android-lib" target="_blank" rel="noopener">bither-android-lib</a> 项目下面的 jni 文件<br>2、turbo.c 是我们自己写的 jni 接口，通过调用 include 中的 API，计算好结果后然后回调给 java 层<br>3、CMakeLists.txt 编译 cpp 文件</p><p>我们先来看下 CmakeLists.txt(cmake 的具体介绍可以看 <a href="https://juejin.im/post/5b9879976fb9a05d330aa206" target="_blank" rel="noopener">cmake 必知</a>):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.4</span><span class="number">.1</span>)</span><br><span class="line"><span class="comment">// 指定要编译的库 luban，并将指定 turbo.c 文件</span></span><br><span class="line">add_library( luban</span><br><span class="line">             SHARED</span><br><span class="line">             src/main/cpp/turbo.c )</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将头文件添加到搜索路径中</span></span><br><span class="line">include_directories(src/main/cpp/include)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 指定要编译的库 jpeg</span></span><br><span class="line">add_library( jpeg SHARED IMPORTED )</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置库的一些属性</span></span><br><span class="line">set_target_properties(  jpeg</span><br><span class="line">                        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                        $&#123;CMAKE_SOURCE_DIR&#125;/libs/$&#123;ANDROID_ABI&#125;/libjpeg-turbo.a )</span><br><span class="line"><span class="comment">// 添加 Android log 库</span></span><br><span class="line">find_library( <span class="built_in">log</span>-lib <span class="built_in">log</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将库与其他库相关联</span></span><br><span class="line">target_link_libraries( luban</span><br><span class="line">                       jpeg</span><br><span class="line">                       jnigraphics <span class="comment">// 这个地方需要注意一下这个库，这个库是可以直接操作 Android Bitmap 信息的 </span></span><br><span class="line">                       $&#123;<span class="built_in">log</span>-lib&#125;)</span><br></pre></td></tr></table></figure></p><p><br>然后来看下 <a href="https://github.com/Curzibn/Luban-Turbo/blob/1a8b19f3fca86f77cd95a377ee7834d62c636185/app/src/main/cpp/turbo.c" target="_blank" rel="noopener">turbo.c</a>  的主要片段代码，主要设置步骤如下<br><br><br>1、获取 Bitmap 相关的信息，例如 bitmap 的宽度、高度、像素点颜色值<br>具体可看代码 <a href="https://github.com/Curzibn/Luban-Turbo/blob/1a8b19f3fca86f77cd95a377ee7834d62c636185/app/src/main/cpp/turbo.c#L65-L86" target="_blank" rel="noopener">nativeCompress 方法的 65~86 行</a><br><br><br>2、将 Bitmap 中每个像素点的颜色值存储起来：<br>①、动态分配一块内存空间大小为 bitmap 的宽度<em>高度</em>3，这个 3 指的是 R、G、B </p><blockquote><p>data = malloc((size_t) (width <em> height </em> 3)); </p></blockquote><p>②、pixelColor 像素缓存地址的指针，循环遍历 bitmap 的颜色值，并存储到 *data 中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; height; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; width; j++) &#123;</span><br><span class="line">            color = *((int *) pixelColor);</span><br><span class="line">            r = (BYTE) ((color &amp; 0x00FF0000) &gt;&gt; 16);</span><br><span class="line">            g = (BYTE) ((color &amp; 0x0000FF00) &gt;&gt; 8);</span><br><span class="line">            b = (BYTE) (color &amp; 0X000000FF);</span><br><span class="line"> </span><br><span class="line">            *data = b;</span><br><span class="line">            *(data + 1) = g;</span><br><span class="line">            *(data + 2) = r;</span><br><span class="line">            data += 3;</span><br><span class="line">            pixelColor += 4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>具体可看代码 <a href="https://github.com/Curzibn/Luban-Turbo/blob/1a8b19f3fca86f77cd95a377ee7834d62cnativeCompress%20%E6%96%B9%E6%B3%95%E7%9A%84%2065~86%20%E8%A1%8C636185/app/src/main/cpp/turbo.c#L88-L106" target="_blank" rel="noopener">nativeCompress 方法的 88~106 行</a><br><br><br>3、通过 libjpeg API 来压缩 *data 数据，并存储到一个文件中<br>具体代码可以查看 <a href="https://github.com/Curzibn/Luban-Turbo/blob/1a8b19f3fca86f77cd95a377ee7834d62cnativeCompress%20%E6%96%B9%E6%B3%95%E7%9A%84%2065~86%20%E8%A1%8C636185/app/src/main/cpp/turbo.c#L88-L106" target="_blank" rel="noopener">generateJpg 方法的 18~59 行</a> ，这个地方不再去阐述的原因是，在参考的很多项目中，这个部分的代码几乎都是一模一样，这个地方需要注意一下 <code>jcs.optimize_coding = TRUE;</code> ，由于设置成 true，给压缩的质量提高了 5~10 倍的效果，具体可以看开题的 REASON.md <br><br><br></p><p><a name="JK9DV"></a></p><h3 id="2、EffectiveBitmap"><a href="#2、EffectiveBitmap" class="headerlink" title="2、EffectiveBitmap"></a>2、EffectiveBitmap</h3><p><a href="https://github.com/zengfw/EffectiveBitmap" target="_blank" rel="noopener">EffectiveBitmap</a> 几乎和 <a href="https://github.com/Curzibn/Luban-Turbo" target="_blank" rel="noopener">Luban-Turbo</a> 一模一样，只是代码变量换了一下而已，看了一下两个库的构建时间</p><ul><li>luban-turbo : 2018-7-20 ,具体可看 <a href="https://github.com/Curzibn/Luban-Turbo/commit/1a8b19f3fca86f77cd95a377ee7834d62c636185" target="_blank" rel="noopener">commit</a> </li><li>EffectiveBitmap：2018-4-12 ，具体可看 <a href="https://github.com/zengfw/EffectiveBitmap/commit/bef59066a4b50877015d54572b2f31dafcd3bb7b" target="_blank" rel="noopener">commit</a></li></ul><p>说代码差不多雷同其实也没什么，主要是因为官方给过一份 turbo 的 <a href="https://github.com/libjpeg-turbo/libjpeg-turbo/blob/52291467e1d24ed5c99186b93722e740902bd19c/example.txt#L86-L191" target="_blank" rel="noopener">example</a>，人家就是这么写的，我们就是这么调用的，一样的能怪我嘛! </p><p><a name="bLlXJ"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>libjpeg 仅支持将压缩的结果设置到一个文件中，不能返回一个 bitmap ，如果压缩的目标是一个 File 文件，可以将文件先 <code>BitmapFactory.decodeFile(filePath, options);</code>  转成 bitmap，然后调用 native 方法，这个是从上述的两个案例中参考得出的，官方还提供了解压缩的方法，具体看以看 example 中 <a href="https://github.com/libjpeg-turbo/libjpeg-turbo/blob/52291467e1d24ed5c99186b93722e740902bd19c/example.txt#L299-L438" target="_blank" rel="noopener">read_JPEG_file</a> 函数。</p><p><a name="kHqsY"></a></p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ul><li>Android JNI 之 Bitmap 操作 <a href="https://juejin.im/post/5b5810a56fb9a04f8c5ee296" target="_blank" rel="noopener">https://juejin.im/post/5b5810a56fb9a04f8c5ee296</a></li><li>Android NDK 开发之 CMake 必知必会 <a href="https://juejin.im/post/5b9879976fb9a05d330aa206" target="_blank" rel="noopener">https://juejin.im/post/5b9879976fb9a05d330aa206</a></li></ul>]]></content>
      
      
      
    </entry>
    
  
  
</search>
